<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cartesian Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        canvas {
            display: block;
        }

        /* Tooltip near cursor */
        #tooltip {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            font-family: 'Consolas', monospace;
            display: none;
            white-space: nowrap;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        /* Fixed coord display bottom-left */
        #coordBox {
            position: fixed;
            bottom: 12px;
            left: 12px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.75);
            color: #0f0;
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Consolas', monospace;
            border: 1px solid rgba(0, 255, 0, 0.25);
        }

        /* Control panel top-left */
        #controls {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 50;
            background: rgba(16, 16, 40, 0.92);
            padding: 14px 16px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(100, 100, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 170px;
        }

        #controls label {
            color: #aab;
            font-size: 13px;
        }

        #controls input[type="color"] {
            width: 100%;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        #controls button {
            padding: 8px 0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.15s;
        }

        #btnNewRoom {
            background: #2d6a4f;
            color: #fff;
        }

        #btnNewRoom:hover {
            background: #40916c;
        }

        #btnUndo {
            background: #c1121f;
            color: #fff;
        }

        #btnUndo:hover {
            background: #e5383b;
        }

        #btnExport {
            background: #023e8a;
            color: #fff;
        }

        #btnExport:hover {
            background: #0077b6;
        }

        #roomLabel {
            color: #7ecbf5;
            font-size: 12px;
            text-align: center;
            padding: 4px;
            background: rgba(0, 100, 200, 0.15);
            border-radius: 4px;
        }

        /* Mode toggle */
        .mode-toggle {
            display: flex;
            gap: 0;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(100, 100, 255, 0.25);
        }

        .mode-toggle input[type="radio"] {
            display: none;
        }

        .mode-toggle label {
            flex: 1;
            text-align: center;
            padding: 7px 0;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #889;
            background: rgba(255, 255, 255, 0.04);
            transition: all 0.15s;
        }

        .mode-toggle input[type="radio"]:checked+label {
            background: rgba(100, 140, 255, 0.25);
            color: #fff;
        }

        #closedNotice {
            color: #4ade80;
            font-size: 11px;
            text-align: center;
            padding: 3px;
            display: none;
            animation: flashNotice 1.5s ease-out forwards;
        }

        @keyframes flashNotice {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                display: none;
            }
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>
    <div id="tooltip"></div>
    <div id="coordBox">( 0 , 0 )</div>

    <div id="controls">
        <!-- Mode toggle -->
        <div class="mode-toggle">
            <input type="radio" name="mode" id="modeDraw" value="draw" checked>
            <label for="modeDraw">✏ Draw</label>
            <input type="radio" name="mode" id="modeMove" value="move">
            <label for="modeMove">✋ Move</label>
        </div>

        <label>Edge Color</label>
        <input type="color" id="colorPicker" value="#00ffcc">
        <button id="btnNewRoom">＋ New Room</button>
        <button id="btnUndo">↩ Undo</button>
        <button id="btnExport">⬇ Export Data</button>
        <div id="roomLabel">Room 0</div>
        <div id="closedNotice">✔ Room closed!</div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('tooltip');
            const coordBox = document.getElementById('coordBox');
            const colorPicker = document.getElementById('colorPicker');
            const roomLabel = document.getElementById('roomLabel');
            const closedNotice = document.getElementById('closedNotice');
            const modeDraw = document.getElementById('modeDraw');
            const modeMove = document.getElementById('modeMove');

            // --- State ---
            let W, H;
            let originX, originY;
            let scale = 30;
            const MIN_SCALE = 5, MAX_SCALE = 200;

            // Pan state
            let isPanning = false;
            let panStartX, panStartY, panOriginStartX, panOriginStartY;

            // Draw state
            let isDrawing = false;
            let drawStartWorld = null;
            let mouseScreenX = 0, mouseScreenY = 0;

            // Current tool: 'draw' or 'move'
            function currentMode() {
                return modeDraw.checked ? 'draw' : 'move';
            }

            // Data
            let rooms = [{ roomId: 0, edges: [], color: colorPicker.value, closed: false }];
            let currentRoomIndex = 0;

            // --- Random distinct color generator ---
            let hueCounter = 0;
            function randomColor() {
                // golden-angle offset for well-distributed hues
                hueCounter += 137.508;
                const h = hueCounter % 360;
                return `hsl(${Math.round(h)}, 80%, 60%)`;
            }

            // --- Resize ---
            function resize() {
                W = canvas.width = window.innerWidth;
                H = canvas.height = window.innerHeight;
                if (originX === undefined) { originX = W / 2; originY = H / 2; }
                draw();
            }
            window.addEventListener('resize', resize);
            resize();

            // --- Mode toggle → cursor ---
            function updateCursor() {
                canvas.style.cursor = currentMode() === 'draw' ? 'crosshair' : 'grab';
            }
            modeDraw.addEventListener('change', updateCursor);
            modeMove.addEventListener('change', updateCursor);
            updateCursor();

            // --- Coordinate transforms ---
            function screenToWorld(sx, sy) {
                return {
                    x: (sx - originX) / scale,
                    y: -(sy - originY) / scale
                };
            }
            function worldToScreen(wx, wy) {
                return {
                    x: originX + wx * scale,
                    y: originY - wy * scale
                };
            }
            function snap(v) { return Math.round(v); }

            // --- Adaptive label step ---
            function labelStep() {
                // pixels per unit → choose step so labels are ~80-150px apart
                const pxPerUnit = scale;
                const targetGapPx = 100;
                const rawStep = targetGapPx / pxPerUnit;
                // round up to a "nice" number: 1,2,5,10,20,50,100,...
                const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
                const residual = rawStep / mag;
                let nice;
                if (residual <= 1) nice = 1;
                else if (residual <= 2) nice = 2;
                else if (residual <= 5) nice = 5;
                else nice = 10;
                return Math.max(1, nice * mag);
            }

            // --- Drawing ---
            function draw() {
                ctx.clearRect(0, 0, W, H);
                drawGrid();
                drawAxes();
                drawAxisLabels();
                drawEdges();
                drawRoomFills();
                if (isDrawing && drawStartWorld) drawPreview();
            }

            function drawGrid() {
                let gridUnit = 1;
                if (scale < 12) gridUnit = 5;
                if (scale < 6) gridUnit = 10;

                const worldTL = screenToWorld(0, 0);
                const worldBR = screenToWorld(W, H);

                const xMin = Math.floor(worldTL.x / gridUnit) * gridUnit;
                const xMax = Math.ceil(worldBR.x / gridUnit) * gridUnit;
                const yMin = Math.floor(worldBR.y / gridUnit) * gridUnit;
                const yMax = Math.ceil(worldTL.y / gridUnit) * gridUnit;

                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let x = xMin; x <= xMax; x += gridUnit) {
                    const s = worldToScreen(x, 0);
                    ctx.moveTo(Math.round(s.x) + 0.5, 0);
                    ctx.lineTo(Math.round(s.x) + 0.5, H);
                }
                for (let y = yMin; y <= yMax; y += gridUnit) {
                    const s = worldToScreen(0, y);
                    ctx.moveTo(0, Math.round(s.y) + 0.5);
                    ctx.lineTo(W, Math.round(s.y) + 0.5);
                }
                ctx.stroke();
            }

            function drawAxes() {
                const o = worldToScreen(0, 0);
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = 'rgba(255,80,80,0.5)';
                ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(W, o.y); ctx.stroke();
                ctx.strokeStyle = 'rgba(80,255,80,0.5)';
                ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, H); ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(o.x, o.y, 3, 0, Math.PI * 2); ctx.fill();
            }

            function drawAxisLabels() {
                const step = labelStep();
                const worldTL = screenToWorld(0, 0);
                const worldBR = screenToWorld(W, H);
                const o = worldToScreen(0, 0);

                ctx.font = '11px Consolas, monospace';
                ctx.fillStyle = '#666';
                ctx.textBaseline = 'top';

                // X-axis labels
                const xStart = Math.ceil(worldTL.x / step) * step;
                const xEnd = Math.floor(worldBR.x / step) * step;
                for (let x = xStart; x <= xEnd; x += step) {
                    if (x === 0) continue;
                    const s = worldToScreen(x, 0);
                    const label = String(Math.round(x));
                    ctx.textAlign = 'center';
                    // place just below the X axis (or at bottom edge if axis off-screen)
                    const yPos = Math.min(Math.max(o.y + 6, 2), H - 14);
                    ctx.fillText(label, s.x, yPos);
                }

                // Y-axis labels
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'left';
                const yStart = Math.ceil(worldBR.y / step) * step;
                const yEnd = Math.floor(worldTL.y / step) * step;
                for (let y = yStart; y <= yEnd; y += step) {
                    if (y === 0) continue;
                    const s = worldToScreen(0, y);
                    const label = String(Math.round(y));
                    // place just to the right of the Y axis
                    const xPos = Math.min(Math.max(o.x + 6, 2), W - 30);
                    ctx.fillText(label, xPos, s.y);
                }
            }

            function drawEdges() {
                for (const room of rooms) {
                    for (const edge of room.edges) {
                        const [p1, p2] = edge;
                        const s1 = worldToScreen(p1[0], p1[1]);
                        const s2 = worldToScreen(p2[0], p2[1]);
                        ctx.strokeStyle = room.color || '#0fc';
                        ctx.lineWidth = 2.5;
                        ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(s1.x, s1.y, 3, 0, Math.PI * 2); ctx.fill();
                        ctx.beginPath(); ctx.arc(s2.x, s2.y, 3, 0, Math.PI * 2); ctx.fill();
                    }
                }
            }

            function drawRoomFills() {
                // light fill for closed rooms
                for (const room of rooms) {
                    if (!room.closed || room.edges.length < 3) continue;
                    // Build ordered vertices from edges
                    const verts = room.edges.map(e => e[0]); // take first point of each edge
                    ctx.beginPath();
                    const s0 = worldToScreen(verts[0][0], verts[0][1]);
                    ctx.moveTo(s0.x, s0.y);
                    for (let i = 1; i < verts.length; i++) {
                        const s = worldToScreen(verts[i][0], verts[i][1]);
                        ctx.lineTo(s.x, s.y);
                    }
                    ctx.closePath();
                    ctx.fillStyle = room.color.replace(')', ', 0.08)').replace('hsl(', 'hsla(').replace('rgb(', 'rgba(');
                    // Fallback if color is hex
                    if (room.color.startsWith('#')) {
                        const r = parseInt(room.color.slice(1, 3), 16);
                        const g = parseInt(room.color.slice(3, 5), 16);
                        const b = parseInt(room.color.slice(5, 7), 16);
                        ctx.fillStyle = `rgba(${r},${g},${b},0.08)`;
                    }
                    ctx.fill();
                }
            }

            function drawPreview() {
                const s1 = worldToScreen(drawStartWorld.x, drawStartWorld.y);
                const curWorld = screenToWorld(mouseScreenX, mouseScreenY);
                const snapped = { x: snap(curWorld.x), y: snap(curWorld.y) };
                const s2 = worldToScreen(snapped.x, snapped.y);

                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
                ctx.setLineDash([]);

                const dx = snapped.x - drawStartWorld.x;
                const dy = snapped.y - drawStartWorld.y;
                const len = Math.sqrt(dx * dx + dy * dy).toFixed(2);
                const mx = (s1.x + s2.x) / 2;
                const my = (s1.y + s2.y) / 2;
                ctx.font = '13px Consolas, monospace';
                ctx.fillStyle = '#ff0';
                ctx.fillText(`L=${len}`, mx + 8, my - 8);

                ctx.fillStyle = 'rgba(255,255,0,0.6)';
                ctx.beginPath(); ctx.arc(s2.x, s2.y, 4, 0, Math.PI * 2); ctx.fill();

                // Highlight snap-to-first-vertex when near it
                const room = rooms[currentRoomIndex];
                if (room.edges.length >= 2) {
                    const first = room.edges[0][0];
                    if (snapped.x === first[0] && snapped.y === first[1]) {
                        const sf = worldToScreen(first[0], first[1]);
                        ctx.strokeStyle = '#4ade80';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(sf.x, sf.y, 8, 0, Math.PI * 2); ctx.stroke();
                        ctx.font = '12px Consolas, monospace';
                        ctx.fillStyle = '#4ade80';
                        ctx.fillText('Close room', sf.x + 12, sf.y - 12);
                    }
                }
            }

            // --- Cycle detection: check if new edge closes the room ---
            function checkRoomClosed(room) {
                if (room.edges.length < 3) return false;
                const firstVertex = room.edges[0][0]; // [x, y]
                const lastEdge = room.edges[room.edges.length - 1];
                const lastVertex = lastEdge[1]; // endpoint of last edge
                return firstVertex[0] === lastVertex[0] && firstVertex[1] === lastVertex[1];
            }

            function autoCloseRoom() {
                const room = rooms[currentRoomIndex];
                room.closed = true;

                // Flash notice
                closedNotice.style.display = 'block';
                closedNotice.style.animation = 'none';
                void closedNotice.offsetHeight; // reflow
                closedNotice.style.animation = 'flashNotice 1.5s ease-out forwards';
                setTimeout(() => { closedNotice.style.display = 'none'; }, 1600);

                // Start new room with auto-color
                const newColor = randomColor();
                const newId = rooms.length;
                rooms.push({ roomId: newId, edges: [], color: newColor, closed: false });
                currentRoomIndex = newId;
                colorPicker.value = hslToHex(newColor);
                roomLabel.textContent = `Room ${newId}`;
            }

            // Helper: convert hsl string to hex for color picker
            function hslToHex(hslStr) {
                const tmp = document.createElement('div');
                tmp.style.color = hslStr;
                document.body.appendChild(tmp);
                const computed = getComputedStyle(tmp).color;
                document.body.removeChild(tmp);
                const m = computed.match(/\d+/g);
                if (!m) return '#ffffff';
                const [r, g, b] = m.map(Number);
                return '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
            }

            // --- Mouse events ---
            canvas.addEventListener('mousemove', (e) => {
                mouseScreenX = e.clientX;
                mouseScreenY = e.clientY;
                const w = screenToWorld(e.clientX, e.clientY);
                const sx = snap(w.x), sy = snap(w.y);

                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 16) + 'px';
                tooltip.style.top = (e.clientY - 10) + 'px';
                tooltip.textContent = `( ${sx} , ${sy} )`;
                coordBox.textContent = `( ${sx} , ${sy} )`;

                // Panning (always active for middle-mouse, or left-drag in move mode)
                if (isPanning) {
                    originX = panOriginStartX + (e.clientX - panStartX);
                    originY = panOriginStartY + (e.clientY - panStartY);
                }

                draw();
            });

            canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    if (currentMode() === 'draw') {
                        // Draw mode: start edge
                        const w = screenToWorld(e.clientX, e.clientY);
                        drawStartWorld = { x: snap(w.x), y: snap(w.y) };
                        isDrawing = true;
                    } else {
                        // Move mode: left-click pan
                        isPanning = true;
                        panStartX = e.clientX; panStartY = e.clientY;
                        panOriginStartX = originX; panOriginStartY = originY;
                        canvas.style.cursor = 'grabbing';
                    }
                }
                // Middle-click: always pan
                if (e.button === 1) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX; panStartY = e.clientY;
                    panOriginStartX = originX; panOriginStartY = originY;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    if (currentMode() === 'draw' && isDrawing && drawStartWorld) {
                        const w = screenToWorld(e.clientX, e.clientY);
                        const end = { x: snap(w.x), y: snap(w.y) };
                        if (end.x !== drawStartWorld.x || end.y !== drawStartWorld.y) {
                            rooms[currentRoomIndex].edges.push([
                                [drawStartWorld.x, drawStartWorld.y],
                                [end.x, end.y]
                            ]);
                            rooms[currentRoomIndex].color = colorPicker.value;

                            // Check for cycle (auto-close)
                            if (checkRoomClosed(rooms[currentRoomIndex])) {
                                autoCloseRoom();
                            }
                        }
                        isDrawing = false;
                        drawStartWorld = null;
                        draw();
                    }
                    if (currentMode() === 'move') {
                        isPanning = false;
                        canvas.style.cursor = 'grab';
                    }
                }
                if (e.button === 1) {
                    isPanning = false;
                    updateCursor();
                }
            });

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            canvas.addEventListener('auxclick', (e) => { if (e.button === 1) e.preventDefault(); });

            // Zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
                const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * zoomFactor));
                const ratio = newScale / scale;
                originX = e.clientX - (e.clientX - originX) * ratio;
                originY = e.clientY - (e.clientY - originY) * ratio;
                scale = newScale;
                draw();
            }, { passive: false });

            // --- Buttons ---
            document.getElementById('btnNewRoom').addEventListener('click', () => {
                const newColor = randomColor();
                const newId = rooms.length;
                rooms.push({ roomId: newId, edges: [], color: newColor, closed: false });
                currentRoomIndex = newId;
                colorPicker.value = hslToHex(newColor);
                roomLabel.textContent = `Room ${newId}`;
                draw();
            });

            document.getElementById('btnUndo').addEventListener('click', () => {
                for (let i = currentRoomIndex; i >= 0; i--) {
                    if (rooms[i].edges.length > 0) {
                        rooms[i].edges.pop();
                        rooms[i].closed = false; // reopen if edge removed
                        draw();
                        return;
                    }
                }
            });

            document.getElementById('btnExport').addEventListener('click', () => {
                const out = rooms.map(r => ({
                    roomId: r.roomId,
                    edges: r.edges
                }));
                const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'map_edges.txt';
                a.click();
                URL.revokeObjectURL(a.href);
            });
        })();
    </script>
</body>

</html>
